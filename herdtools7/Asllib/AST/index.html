<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>AST (herdtools7.Asllib.AST)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">herdtools7</a> &#x00BB; <a href="../index.html">Asllib</a> &#x00BB; AST</nav><header class="odoc-preamble"><h1>Module <code><span>Asllib.AST</span></code></h1><p>An Abstract Syntax Tree for ASL.</p></header><nav class="odoc-toc"><ul><li><a href="#utils">Utils</a></li><li><a href="#operations">Operations</a></li><li><a href="#literals">Literals</a></li><li><a href="#expressions">Expressions</a></li><li><a href="#types">Types</a></li><li><a href="#statements">Statements</a></li><li><a href="#top-level-declarations">Top-level declarations</a></li></ul></nav><div class="odoc-content"><h3 id="utils"><a href="#utils" class="anchor"></a>Utils</h3><div class="odoc-spec"><div class="spec type anchored" id="type-position"><a href="#type-position" class="anchor"></a><code><span><span class="keyword">type</span> position</span><span> = <span class="xref-unresolved">Stdlib</span>.Lexing.position</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-annotated"><a href="#type-annotated" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a annotated</span></span><span> = </span><span>{</span></code><ol><li id="type-annotated.desc" class="def record field anchored"><a href="#type-annotated.desc" class="anchor"></a><code><span>desc : <span class="type-var">'a</span>;</span></code></li><li id="type-annotated.pos_start" class="def record field anchored"><a href="#type-annotated.pos_start" class="anchor"></a><code><span>pos_start : <a href="#type-position">position</a>;</span></code></li><li id="type-annotated.pos_end" class="def record field anchored"><a href="#type-annotated.pos_end" class="anchor"></a><code><span>pos_end : <a href="#type-position">position</a>;</span></code></li></ol><code><span>}</span></code></div></div><h3 id="operations"><a href="#operations" class="anchor"></a>Operations</h3><div class="odoc-spec"><div class="spec type anchored" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span><span class="keyword">type</span> unop</span><span> = </span></code><ol><li id="type-unop.BNOT" class="def variant constructor anchored"><a href="#type-unop.BNOT" class="anchor"></a><code><span>| </span><span><span class="constructor">BNOT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean inversion</p><span class="comment-delim">*)</span></div></li><li id="type-unop.NEG" class="def variant constructor anchored"><a href="#type-unop.NEG" class="anchor"></a><code><span>| </span><span><span class="constructor">NEG</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer or real negation</p><span class="comment-delim">*)</span></div></li><li id="type-unop.NOT" class="def variant constructor anchored"><a href="#type-unop.NOT" class="anchor"></a><code><span>| </span><span><span class="constructor">NOT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector bitwise inversion</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Operations on base value of arity one.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">type</span> binop</span><span> = </span></code><ol><li id="type-binop.AND" class="def variant constructor anchored"><a href="#type-binop.AND" class="anchor"></a><code><span>| </span><span><span class="constructor">AND</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector bitwise and</p><span class="comment-delim">*)</span></div></li><li id="type-binop.BAND" class="def variant constructor anchored"><a href="#type-binop.BAND" class="anchor"></a><code><span>| </span><span><span class="constructor">BAND</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean and</p><span class="comment-delim">*)</span></div></li><li id="type-binop.BEQ" class="def variant constructor anchored"><a href="#type-binop.BEQ" class="anchor"></a><code><span>| </span><span><span class="constructor">BEQ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean equivalence</p><span class="comment-delim">*)</span></div></li><li id="type-binop.BOR" class="def variant constructor anchored"><a href="#type-binop.BOR" class="anchor"></a><code><span>| </span><span><span class="constructor">BOR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean or</p><span class="comment-delim">*)</span></div></li><li id="type-binop.DIV" class="def variant constructor anchored"><a href="#type-binop.DIV" class="anchor"></a><code><span>| </span><span><span class="constructor">DIV</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer division</p><span class="comment-delim">*)</span></div></li><li id="type-binop.DIVRM" class="def variant constructor anchored"><a href="#type-binop.DIVRM" class="anchor"></a><code><span>| </span><span><span class="constructor">DIVRM</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inexact integer division, with rounding towards negative infinity.</p><span class="comment-delim">*)</span></div></li><li id="type-binop.EOR" class="def variant constructor anchored"><a href="#type-binop.EOR" class="anchor"></a><code><span>| </span><span><span class="constructor">EOR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector bitwise exclusive or</p><span class="comment-delim">*)</span></div></li><li id="type-binop.EQ_OP" class="def variant constructor anchored"><a href="#type-binop.EQ_OP" class="anchor"></a><code><span>| </span><span><span class="constructor">EQ_OP</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality on two base values of same type</p><span class="comment-delim">*)</span></div></li><li id="type-binop.GT" class="def variant constructor anchored"><a href="#type-binop.GT" class="anchor"></a><code><span>| </span><span><span class="constructor">GT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater than for int or reals</p><span class="comment-delim">*)</span></div></li><li id="type-binop.GEQ" class="def variant constructor anchored"><a href="#type-binop.GEQ" class="anchor"></a><code><span>| </span><span><span class="constructor">GEQ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater or equal for int or reals</p><span class="comment-delim">*)</span></div></li><li id="type-binop.IMPL" class="def variant constructor anchored"><a href="#type-binop.IMPL" class="anchor"></a><code><span>| </span><span><span class="constructor">IMPL</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean implication</p><span class="comment-delim">*)</span></div></li><li id="type-binop.LT" class="def variant constructor anchored"><a href="#type-binop.LT" class="anchor"></a><code><span>| </span><span><span class="constructor">LT</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less than for int or reals</p><span class="comment-delim">*)</span></div></li><li id="type-binop.LEQ" class="def variant constructor anchored"><a href="#type-binop.LEQ" class="anchor"></a><code><span>| </span><span><span class="constructor">LEQ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less or equal for int or reals</p><span class="comment-delim">*)</span></div></li><li id="type-binop.MOD" class="def variant constructor anchored"><a href="#type-binop.MOD" class="anchor"></a><code><span>| </span><span><span class="constructor">MOD</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Remainder of integer division</p><span class="comment-delim">*)</span></div></li><li id="type-binop.MINUS" class="def variant constructor anchored"><a href="#type-binop.MINUS" class="anchor"></a><code><span>| </span><span><span class="constructor">MINUS</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Substraction for int or reals or bitvectors</p><span class="comment-delim">*)</span></div></li><li id="type-binop.MUL" class="def variant constructor anchored"><a href="#type-binop.MUL" class="anchor"></a><code><span>| </span><span><span class="constructor">MUL</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Multiplication for int or reals or bitvectors</p><span class="comment-delim">*)</span></div></li><li id="type-binop.NEQ" class="def variant constructor anchored"><a href="#type-binop.NEQ" class="anchor"></a><code><span>| </span><span><span class="constructor">NEQ</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Non equality on two base values of same type</p><span class="comment-delim">*)</span></div></li><li id="type-binop.OR" class="def variant constructor anchored"><a href="#type-binop.OR" class="anchor"></a><code><span>| </span><span><span class="constructor">OR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector bitwise or</p><span class="comment-delim">*)</span></div></li><li id="type-binop.PLUS" class="def variant constructor anchored"><a href="#type-binop.PLUS" class="anchor"></a><code><span>| </span><span><span class="constructor">PLUS</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Addition for int or reals or bitvectors</p><span class="comment-delim">*)</span></div></li><li id="type-binop.POW" class="def variant constructor anchored"><a href="#type-binop.POW" class="anchor"></a><code><span>| </span><span><span class="constructor">POW</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Exponentiation for ints</p><span class="comment-delim">*)</span></div></li><li id="type-binop.RDIV" class="def variant constructor anchored"><a href="#type-binop.RDIV" class="anchor"></a><code><span>| </span><span><span class="constructor">RDIV</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Division for reals</p><span class="comment-delim">*)</span></div></li><li id="type-binop.SHL" class="def variant constructor anchored"><a href="#type-binop.SHL" class="anchor"></a><code><span>| </span><span><span class="constructor">SHL</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Shift left for ints</p><span class="comment-delim">*)</span></div></li><li id="type-binop.SHR" class="def variant constructor anchored"><a href="#type-binop.SHR" class="anchor"></a><code><span>| </span><span><span class="constructor">SHR</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Shift right for ints</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Operations on base value of arity two.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-identifier"><a href="#type-identifier" class="anchor"></a><code><span><span class="keyword">type</span> identifier</span><span> = string</span></code></div><div class="spec-doc"><p>Type of local identifiers in the AST.</p></div></div><h3 id="literals"><a href="#literals" class="anchor"></a>Literals</h3><p>Literals are the values written straight into ASL programs. There is only literal constructors for a few concepts that could be encapsulated into an ASL value.</p><div class="odoc-spec"><div class="spec type anchored" id="type-literal"><a href="#type-literal" class="anchor"></a><code><span><span class="keyword">type</span> literal</span><span> = </span></code><ol><li id="type-literal.L_Int" class="def variant constructor anchored"><a href="#type-literal.L_Int" class="anchor"></a><code><span>| </span><span><span class="constructor">L_Int</span> <span class="keyword">of</span> <span class="xref-unresolved">Z</span>.t</span></code></li><li id="type-literal.L_Bool" class="def variant constructor anchored"><a href="#type-literal.L_Bool" class="anchor"></a><code><span>| </span><span><span class="constructor">L_Bool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-literal.L_Real" class="def variant constructor anchored"><a href="#type-literal.L_Real" class="anchor"></a><code><span>| </span><span><span class="constructor">L_Real</span> <span class="keyword">of</span> <span class="xref-unresolved">Q</span>.t</span></code></li><li id="type-literal.L_BitVector" class="def variant constructor anchored"><a href="#type-literal.L_BitVector" class="anchor"></a><code><span>| </span><span><span class="constructor">L_BitVector</span> <span class="keyword">of</span> <a href="../Bitvector/index.html#type-t">Bitvector.t</a></span></code></li><li id="type-literal.L_String" class="def variant constructor anchored"><a href="#type-literal.L_String" class="anchor"></a><code><span>| </span><span><span class="constructor">L_String</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p>Main value type, parametric on its base values</p></div></div><h3 id="expressions"><a href="#expressions" class="anchor"></a>Expressions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-expr_desc"><a href="#type-expr_desc" class="anchor"></a><code><span><span class="keyword">type</span> expr_desc</span><span> = </span></code><ol><li id="type-expr_desc.E_Literal" class="def variant constructor anchored"><a href="#type-expr_desc.E_Literal" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Literal</span> <span class="keyword">of</span> <a href="#type-literal">literal</a></span></code></li><li id="type-expr_desc.E_Var" class="def variant constructor anchored"><a href="#type-expr_desc.E_Var" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Var</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a></span></code></li><li id="type-expr_desc.E_Typed" class="def variant constructor anchored"><a href="#type-expr_desc.E_Typed" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Typed</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-ty">ty</a></span></code></li><li id="type-expr_desc.E_Binop" class="def variant constructor anchored"><a href="#type-expr_desc.E_Binop" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Binop</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr_desc.E_Unop" class="def variant constructor anchored"><a href="#type-expr_desc.E_Unop" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Unop</span> <span class="keyword">of</span> <a href="#type-unop">unop</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr_desc.E_Call" class="def variant constructor anchored"><a href="#type-expr_desc.E_Call" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Call</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-expr">expr</a> list</span> * <span><span>(<a href="#type-identifier">identifier</a> * <a href="#type-expr">expr</a>)</span> list</span></span></code></li><li id="type-expr_desc.E_Slice" class="def variant constructor anchored"><a href="#type-expr_desc.E_Slice" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Slice</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-slice">slice</a> list</span></span></code></li><li id="type-expr_desc.E_Cond" class="def variant constructor anchored"><a href="#type-expr_desc.E_Cond" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Cond</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr_desc.E_GetArray" class="def variant constructor anchored"><a href="#type-expr_desc.E_GetArray" class="anchor"></a><code><span>| </span><span><span class="constructor">E_GetArray</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr_desc.E_GetField" class="def variant constructor anchored"><a href="#type-expr_desc.E_GetField" class="anchor"></a><code><span>| </span><span><span class="constructor">E_GetField</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-identifier">identifier</a></span></code></li><li id="type-expr_desc.E_GetFields" class="def variant constructor anchored"><a href="#type-expr_desc.E_GetFields" class="anchor"></a><code><span>| </span><span><span class="constructor">E_GetFields</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-identifier">identifier</a> list</span></span></code></li><li id="type-expr_desc.E_Record" class="def variant constructor anchored"><a href="#type-expr_desc.E_Record" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Record</span> <span class="keyword">of</span> <a href="#type-ty">ty</a> * <span><span>(<a href="#type-identifier">identifier</a> * <a href="#type-expr">expr</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Represents a record or an exception construction expression.</p><span class="comment-delim">*)</span></div></li><li id="type-expr_desc.E_Concat" class="def variant constructor anchored"><a href="#type-expr_desc.E_Concat" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Concat</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span></span></code></li><li id="type-expr_desc.E_Tuple" class="def variant constructor anchored"><a href="#type-expr_desc.E_Tuple" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Tuple</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span></span></code></li><li id="type-expr_desc.E_Unknown" class="def variant constructor anchored"><a href="#type-expr_desc.E_Unknown" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Unknown</span> <span class="keyword">of</span> <a href="#type-ty">ty</a></span></code></li><li id="type-expr_desc.E_Pattern" class="def variant constructor anchored"><a href="#type-expr_desc.E_Pattern" class="anchor"></a><code><span>| </span><span><span class="constructor">E_Pattern</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-pattern">pattern</a></span></code></li></ol></div><div class="spec-doc"><p>Expressions. Parametric on the type of literals.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">and</span> expr</span><span> = <span><a href="#type-expr_desc">expr_desc</a> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">and</span> pattern</span><span> = </span></code><ol><li id="type-pattern.Pattern_All" class="def variant constructor anchored"><a href="#type-pattern.Pattern_All" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_All</span></span></code></li><li id="type-pattern.Pattern_Any" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Any" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Any</span> <span class="keyword">of</span> <span><a href="#type-pattern">pattern</a> list</span></span></code></li><li id="type-pattern.Pattern_Geq" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Geq</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li><li id="type-pattern.Pattern_Leq" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Leq</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li><li id="type-pattern.Pattern_Mask" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Mask" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Mask</span> <span class="keyword">of</span> <a href="../Bitvector/index.html#type-mask">Bitvector.mask</a></span></code></li><li id="type-pattern.Pattern_Not" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Not</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a></span></code></li><li id="type-pattern.Pattern_Range" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Range" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Range</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-pattern.Pattern_Single" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Single" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Single</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li><li id="type-pattern.Pattern_Tuple" class="def variant constructor anchored"><a href="#type-pattern.Pattern_Tuple" class="anchor"></a><code><span>| </span><span><span class="constructor">Pattern_Tuple</span> <span class="keyword">of</span> <span><a href="#type-pattern">pattern</a> list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-slice"><a href="#type-slice" class="anchor"></a><code><span><span class="keyword">and</span> slice</span><span> = </span></code><ol><li id="type-slice.Slice_Single" class="def variant constructor anchored"><a href="#type-slice.Slice_Single" class="anchor"></a><code><span>| </span><span><span class="constructor">Slice_Single</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Slice_Single i</code> is the slice of length <code>1</code> at position <code>i</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-slice.Slice_Range" class="def variant constructor anchored"><a href="#type-slice.Slice_Range" class="anchor"></a><code><span>| </span><span><span class="constructor">Slice_Range</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Slice_Range (j, i)</code> denotes the slice from <code>i</code> to <code>j - 1</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-slice.Slice_Length" class="def variant constructor anchored"><a href="#type-slice.Slice_Length" class="anchor"></a><code><span>| </span><span><span class="constructor">Slice_Length</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Slice_Length (i, n)</code> denotes the slice starting at <code>i</code> of length <code>n</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-slice.Slice_Star" class="def variant constructor anchored"><a href="#type-slice.Slice_Star" class="anchor"></a><code><span>| </span><span><span class="constructor">Slice_Star</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Slice_Start (factor, length)</code> denotes the slice starting at <code>factor
          * length</code> of length <code>n</code>.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Indexes an array, a bitvector.</p><p>All position mentionned above are included.</p></div></div><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type anchored" id="type-type_desc"><a href="#type-type_desc" class="anchor"></a><code><span><span class="keyword">and</span> type_desc</span><span> = </span></code><ol><li id="type-type_desc.T_Int" class="def variant constructor anchored"><a href="#type-type_desc.T_Int" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Int</span> <span class="keyword">of</span> <span><a href="#type-int_constraints">int_constraints</a> option</span></span></code></li><li id="type-type_desc.T_Real" class="def variant constructor anchored"><a href="#type-type_desc.T_Real" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Real</span></span></code></li><li id="type-type_desc.T_String" class="def variant constructor anchored"><a href="#type-type_desc.T_String" class="anchor"></a><code><span>| </span><span><span class="constructor">T_String</span></span></code></li><li id="type-type_desc.T_Bool" class="def variant constructor anchored"><a href="#type-type_desc.T_Bool" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Bool</span></span></code></li><li id="type-type_desc.T_Bits" class="def variant constructor anchored"><a href="#type-type_desc.T_Bits" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Bits</span> <span class="keyword">of</span> <a href="#type-bits_constraint">bits_constraint</a> * <span><a href="#type-bitfield">bitfield</a> list</span></span></code></li><li id="type-type_desc.T_Enum" class="def variant constructor anchored"><a href="#type-type_desc.T_Enum" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Enum</span> <span class="keyword">of</span> <span><a href="#type-identifier">identifier</a> list</span></span></code></li><li id="type-type_desc.T_Tuple" class="def variant constructor anchored"><a href="#type-type_desc.T_Tuple" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Tuple</span> <span class="keyword">of</span> <span><a href="#type-ty">ty</a> list</span></span></code></li><li id="type-type_desc.T_Array" class="def variant constructor anchored"><a href="#type-type_desc.T_Array" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Array</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-ty">ty</a></span></code></li><li id="type-type_desc.T_Record" class="def variant constructor anchored"><a href="#type-type_desc.T_Record" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Record</span> <span class="keyword">of</span> <span><a href="#type-field">field</a> list</span></span></code></li><li id="type-type_desc.T_Exception" class="def variant constructor anchored"><a href="#type-type_desc.T_Exception" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Exception</span> <span class="keyword">of</span> <span><a href="#type-field">field</a> list</span></span></code></li><li id="type-type_desc.T_Named" class="def variant constructor anchored"><a href="#type-type_desc.T_Named" class="anchor"></a><code><span>| </span><span><span class="constructor">T_Named</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A type variable.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type descriptors.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span><span class="keyword">and</span> ty</span><span> = <span><a href="#type-type_desc">type_desc</a> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-int_constraint"><a href="#type-int_constraint" class="anchor"></a><code><span><span class="keyword">and</span> int_constraint</span><span> = </span></code><ol><li id="type-int_constraint.Constraint_Exact" class="def variant constructor anchored"><a href="#type-int_constraint.Constraint_Exact" class="anchor"></a><code><span>| </span><span><span class="constructor">Constraint_Exact</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Exactly this value, as given by a statically evaluable expression.</p><span class="comment-delim">*)</span></div></li><li id="type-int_constraint.Constraint_Range" class="def variant constructor anchored"><a href="#type-int_constraint.Constraint_Range" class="anchor"></a><code><span>| </span><span><span class="constructor">Constraint_Range</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>In the range of these two statically evaluable values.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>A constraint on an integer part.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-int_constraints"><a href="#type-int_constraints" class="anchor"></a><code><span><span class="keyword">and</span> int_constraints</span><span> = <span><a href="#type-int_constraint">int_constraint</a> list</span></span></code></div><div class="spec-doc"><p>The int_constraints represent the union of the individual constraints.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bits_constraint"><a href="#type-bits_constraint" class="anchor"></a><code><span><span class="keyword">and</span> bits_constraint</span><span> = </span></code><ol><li id="type-bits_constraint.BitWidth_SingleExpr" class="def variant constructor anchored"><a href="#type-bits_constraint.BitWidth_SingleExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">BitWidth_SingleExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Statically evaluable expression.</p><span class="comment-delim">*)</span></div></li><li id="type-bits_constraint.BitWidth_ConstrainedFormType" class="def variant constructor anchored"><a href="#type-bits_constraint.BitWidth_ConstrainedFormType" class="anchor"></a><code><span>| </span><span><span class="constructor">BitWidth_ConstrainedFormType</span> <span class="keyword">of</span> <a href="#type-ty">ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constrained by the domain of another type.</p><span class="comment-delim">*)</span></div></li><li id="type-bits_constraint.BitWidth_Constraints" class="def variant constructor anchored"><a href="#type-bits_constraint.BitWidth_Constraints" class="anchor"></a><code><span>| </span><span><span class="constructor">BitWidth_Constraints</span> <span class="keyword">of</span> <a href="#type-int_constraints">int_constraints</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constrained directly by a constraint on its width.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The width of a bitvector can be constrained in multiple ways.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bitfield"><a href="#type-bitfield" class="anchor"></a><code><span><span class="keyword">and</span> bitfield</span><span> = </span></code><ol><li id="type-bitfield.BitField_Simple" class="def variant constructor anchored"><a href="#type-bitfield.BitField_Simple" class="anchor"></a><code><span>| </span><span><span class="constructor">BitField_Simple</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-slice">slice</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A name and its corresponding slice</p><span class="comment-delim">*)</span></div></li><li id="type-bitfield.BitField_Nested" class="def variant constructor anchored"><a href="#type-bitfield.BitField_Nested" class="anchor"></a><code><span>| </span><span><span class="constructor">BitField_Nested</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-slice">slice</a> list</span> * <span><a href="#type-bitfield">bitfield</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A name, its corresponding slice and some nested bitfields.</p><span class="comment-delim">*)</span></div></li><li id="type-bitfield.BitField_Type" class="def variant constructor anchored"><a href="#type-bitfield.BitField_Type" class="anchor"></a><code><span>| </span><span><span class="constructor">BitField_Type</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-slice">slice</a> list</span> * <a href="#type-ty">ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A name, its corresponding slice and the type of the bitfield.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Represent static slices on a given bitvector type.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-field"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">and</span> field</span><span> = <a href="#type-identifier">identifier</a> * <a href="#type-ty">ty</a></span></code></div><div class="spec-doc"><p>A field of a record-like structure.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-typed_identifier"><a href="#type-typed_identifier" class="anchor"></a><code><span><span class="keyword">and</span> typed_identifier</span><span> = <a href="#type-identifier">identifier</a> * <a href="#type-ty">ty</a></span></code></div><div class="spec-doc"><p>An identifier declared with its type.</p></div></div><h3 id="statements"><a href="#statements" class="anchor"></a>Statements</h3><div class="odoc-spec"><div class="spec type anchored" id="type-lexpr_desc"><a href="#type-lexpr_desc" class="anchor"></a><code><span><span class="keyword">type</span> lexpr_desc</span><span> = </span></code><ol><li id="type-lexpr_desc.LE_Ignore" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_Ignore" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_Ignore</span></span></code></li><li id="type-lexpr_desc.LE_Var" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_Var" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_Var</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a></span></code></li><li id="type-lexpr_desc.LE_Slice" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_Slice" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_Slice</span> <span class="keyword">of</span> <a href="#type-lexpr">lexpr</a> * <span><a href="#type-slice">slice</a> list</span></span></code></li><li id="type-lexpr_desc.LE_SetArray" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_SetArray" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_SetArray</span> <span class="keyword">of</span> <a href="#type-lexpr">lexpr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-lexpr_desc.LE_SetField" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_SetField" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_SetField</span> <span class="keyword">of</span> <a href="#type-lexpr">lexpr</a> * <a href="#type-identifier">identifier</a></span></code></li><li id="type-lexpr_desc.LE_SetFields" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_SetFields" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_SetFields</span> <span class="keyword">of</span> <a href="#type-lexpr">lexpr</a> * <span><a href="#type-identifier">identifier</a> list</span></span></code></li><li id="type-lexpr_desc.LE_TupleUnpack" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_TupleUnpack" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_TupleUnpack</span> <span class="keyword">of</span> <span><a href="#type-lexpr">lexpr</a> list</span></span></code></li><li id="type-lexpr_desc.LE_Concat" class="def variant constructor anchored"><a href="#type-lexpr_desc.LE_Concat" class="anchor"></a><code><span>| </span><span><span class="constructor">LE_Concat</span> <span class="keyword">of</span> <span><a href="#type-lexpr">lexpr</a> list</span> * <span><span>int list</span> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>LE_Concat (les, _) unpacks the various lexpr. Second argument is a type annotation.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type of left-hand side of assignments.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lexpr"><a href="#type-lexpr" class="anchor"></a><code><span><span class="keyword">and</span> lexpr</span><span> = <span><a href="#type-lexpr_desc">lexpr_desc</a> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-local_decl_keyword"><a href="#type-local_decl_keyword" class="anchor"></a><code><span><span class="keyword">type</span> local_decl_keyword</span><span> = </span></code><ol><li id="type-local_decl_keyword.LDK_Var" class="def variant constructor anchored"><a href="#type-local_decl_keyword.LDK_Var" class="anchor"></a><code><span>| </span><span><span class="constructor">LDK_Var</span></span></code></li><li id="type-local_decl_keyword.LDK_Constant" class="def variant constructor anchored"><a href="#type-local_decl_keyword.LDK_Constant" class="anchor"></a><code><span>| </span><span><span class="constructor">LDK_Constant</span></span></code></li><li id="type-local_decl_keyword.LDK_Let" class="def variant constructor anchored"><a href="#type-local_decl_keyword.LDK_Let" class="anchor"></a><code><span>| </span><span><span class="constructor">LDK_Let</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-local_decl_item"><a href="#type-local_decl_item" class="anchor"></a><code><span><span class="keyword">type</span> local_decl_item</span><span> = </span></code><ol><li id="type-local_decl_item.LDI_Var" class="def variant constructor anchored"><a href="#type-local_decl_item.LDI_Var" class="anchor"></a><code><span>| </span><span><span class="constructor">LDI_Var</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-ty">ty</a> option</span></span></code></li><li id="type-local_decl_item.LDI_Ignore" class="def variant constructor anchored"><a href="#type-local_decl_item.LDI_Ignore" class="anchor"></a><code><span>| </span><span><span class="constructor">LDI_Ignore</span> <span class="keyword">of</span> <span><a href="#type-ty">ty</a> option</span></span></code></li><li id="type-local_decl_item.LDI_Tuple" class="def variant constructor anchored"><a href="#type-local_decl_item.LDI_Tuple" class="anchor"></a><code><span>| </span><span><span class="constructor">LDI_Tuple</span> <span class="keyword">of</span> <span><a href="#type-local_decl_item">local_decl_item</a> list</span> * <span><a href="#type-ty">ty</a> option</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-for_direction"><a href="#type-for_direction" class="anchor"></a><code><span><span class="keyword">type</span> for_direction</span><span> = </span></code><ol><li id="type-for_direction.Up" class="def variant constructor anchored"><a href="#type-for_direction.Up" class="anchor"></a><code><span>| </span><span><span class="constructor">Up</span></span></code></li><li id="type-for_direction.Down" class="def variant constructor anchored"><a href="#type-for_direction.Down" class="anchor"></a><code><span>| </span><span><span class="constructor">Down</span></span></code></li></ol></div><div class="spec-doc"><p>Statements. Parametric on the type of literals in expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-version"><a href="#type-version" class="anchor"></a><code><span><span class="keyword">type</span> version</span><span> = </span></code><ol><li id="type-version.V0" class="def variant constructor anchored"><a href="#type-version.V0" class="anchor"></a><code><span>| </span><span><span class="constructor">V0</span></span></code></li><li id="type-version.V1" class="def variant constructor anchored"><a href="#type-version.V1" class="anchor"></a><code><span>| </span><span><span class="constructor">V1</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stmt_desc"><a href="#type-stmt_desc" class="anchor"></a><code><span><span class="keyword">type</span> stmt_desc</span><span> = </span></code><ol><li id="type-stmt_desc.S_Pass" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Pass" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Pass</span></span></code></li><li id="type-stmt_desc.S_Then" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Then" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Then</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt_desc.S_Decl" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Decl" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Decl</span> <span class="keyword">of</span> <a href="#type-local_decl_keyword">local_decl_keyword</a> * <a href="#type-local_decl_item">local_decl_item</a> * <span><a href="#type-expr">expr</a> option</span></span></code></li><li id="type-stmt_desc.S_Assign" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Assign" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Assign</span> <span class="keyword">of</span> <a href="#type-lexpr">lexpr</a> * <a href="#type-expr">expr</a> * <a href="#type-version">version</a></span></code></li><li id="type-stmt_desc.S_Call" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Call" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Call</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <span><a href="#type-expr">expr</a> list</span> * <span><span>(<a href="#type-identifier">identifier</a> * <a href="#type-expr">expr</a>)</span> list</span></span></code></li><li id="type-stmt_desc.S_Return" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Return" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Return</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> option</span></span></code></li><li id="type-stmt_desc.S_Cond" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Cond" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Cond</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt_desc.S_Case" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Case" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Case</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-case_alt">case_alt</a> list</span></span></code></li><li id="type-stmt_desc.S_Assert" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Assert" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Assert</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li><li id="type-stmt_desc.S_For" class="def variant constructor anchored"><a href="#type-stmt_desc.S_For" class="anchor"></a><code><span>| </span><span><span class="constructor">S_For</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <a href="#type-expr">expr</a> * <a href="#type-for_direction">for_direction</a> * <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt_desc.S_While" class="def variant constructor anchored"><a href="#type-stmt_desc.S_While" class="anchor"></a><code><span>| </span><span><span class="constructor">S_While</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt_desc.S_Repeat" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Repeat" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Repeat</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-stmt_desc.S_Throw" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Throw" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Throw</span> <span class="keyword">of</span> <span><span>(<a href="#type-expr">expr</a> * <span><a href="#type-ty">ty</a> option</span>)</span> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The ty option is a type annotation added by the type-checker to be matched later with the catch guards. The bigger option is to represent the implicit throw, such as <code>throw;</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-stmt_desc.S_Try" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Try" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Try</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a> * <span><a href="#type-catcher">catcher</a> list</span> * <span><a href="#type-stmt">stmt</a> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The stmt option is the optional otherwise guard.</p><span class="comment-delim">*)</span></div></li><li id="type-stmt_desc.S_Debug" class="def variant constructor anchored"><a href="#type-stmt_desc.S_Debug" class="anchor"></a><code><span>| </span><span><span class="constructor">S_Debug</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stmt"><a href="#type-stmt" class="anchor"></a><code><span><span class="keyword">and</span> stmt</span><span> = <span><a href="#type-stmt_desc">stmt_desc</a> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case_alt"><a href="#type-case_alt" class="anchor"></a><code><span><span class="keyword">and</span> case_alt</span><span> = <span><span>(<a href="#type-pattern">pattern</a> * <a href="#type-stmt">stmt</a>)</span> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-catcher"><a href="#type-catcher" class="anchor"></a><code><span><span class="keyword">and</span> catcher</span><span> = <span><a href="#type-identifier">identifier</a> option</span> * <a href="#type-ty">ty</a> * <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>The optional name of the matched exception, the guard type and the statement to be executed if the guard matches.</p></div></div><h3 id="top-level-declarations"><a href="#top-level-declarations" class="anchor"></a>Top-level declarations</h3><div class="odoc-spec"><div class="spec type anchored" id="type-subprogram_type"><a href="#type-subprogram_type" class="anchor"></a><code><span><span class="keyword">type</span> subprogram_type</span><span> = </span></code><ol><li id="type-subprogram_type.ST_Procedure" class="def variant constructor anchored"><a href="#type-subprogram_type.ST_Procedure" class="anchor"></a><code><span>| </span><span><span class="constructor">ST_Procedure</span></span></code></li><li id="type-subprogram_type.ST_Function" class="def variant constructor anchored"><a href="#type-subprogram_type.ST_Function" class="anchor"></a><code><span>| </span><span><span class="constructor">ST_Function</span></span></code></li><li id="type-subprogram_type.ST_Getter" class="def variant constructor anchored"><a href="#type-subprogram_type.ST_Getter" class="anchor"></a><code><span>| </span><span><span class="constructor">ST_Getter</span></span></code></li><li id="type-subprogram_type.ST_Setter" class="def variant constructor anchored"><a href="#type-subprogram_type.ST_Setter" class="anchor"></a><code><span>| </span><span><span class="constructor">ST_Setter</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-subprogram_body"><a href="#type-subprogram_body" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p subprogram_body</span></span><span> = </span></code><ol><li id="type-subprogram_body.SB_ASL" class="def variant constructor anchored"><a href="#type-subprogram_body.SB_ASL" class="anchor"></a><code><span>| </span><span><span class="constructor">SB_ASL</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a></span></code></li><li id="type-subprogram_body.SB_Primitive" class="def variant constructor anchored"><a href="#type-subprogram_body.SB_Primitive" class="anchor"></a><code><span>| </span><span><span class="constructor">SB_Primitive</span> <span class="keyword">of</span> <span class="type-var">'p</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-func"><a href="#type-func" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p func</span></span><span> = </span><span>{</span></code><ol><li id="type-func.name" class="def record field anchored"><a href="#type-func.name" class="anchor"></a><code><span>name : <a href="#type-identifier">identifier</a>;</span></code></li><li id="type-func.parameters" class="def record field anchored"><a href="#type-func.parameters" class="anchor"></a><code><span>parameters : <span><span>(<a href="#type-identifier">identifier</a> * <span><a href="#type-ty">ty</a> option</span>)</span> list</span>;</span></code></li><li id="type-func.args" class="def record field anchored"><a href="#type-func.args" class="anchor"></a><code><span>args : <span><a href="#type-typed_identifier">typed_identifier</a> list</span>;</span></code></li><li id="type-func.body" class="def record field anchored"><a href="#type-func.body" class="anchor"></a><code><span>body : <span><span class="type-var">'p</span> <a href="#type-subprogram_body">subprogram_body</a></span>;</span></code></li><li id="type-func.return_type" class="def record field anchored"><a href="#type-func.return_type" class="anchor"></a><code><span>return_type : <span><a href="#type-ty">ty</a> option</span>;</span></code></li><li id="type-func.subprogram_type" class="def record field anchored"><a href="#type-func.subprogram_type" class="anchor"></a><code><span>subprogram_type : <a href="#type-subprogram_type">subprogram_type</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Function types in the AST. For the moment, they represent getters, setters, functions, procedures and primitives.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-global_decl_keyword"><a href="#type-global_decl_keyword" class="anchor"></a><code><span><span class="keyword">type</span> global_decl_keyword</span><span> = </span></code><ol><li id="type-global_decl_keyword.GDK_Constant" class="def variant constructor anchored"><a href="#type-global_decl_keyword.GDK_Constant" class="anchor"></a><code><span>| </span><span><span class="constructor">GDK_Constant</span></span></code></li><li id="type-global_decl_keyword.GDK_Config" class="def variant constructor anchored"><a href="#type-global_decl_keyword.GDK_Config" class="anchor"></a><code><span>| </span><span><span class="constructor">GDK_Config</span></span></code></li><li id="type-global_decl_keyword.GDK_Let" class="def variant constructor anchored"><a href="#type-global_decl_keyword.GDK_Let" class="anchor"></a><code><span>| </span><span><span class="constructor">GDK_Let</span></span></code></li><li id="type-global_decl_keyword.GDK_Var" class="def variant constructor anchored"><a href="#type-global_decl_keyword.GDK_Var" class="anchor"></a><code><span>| </span><span><span class="constructor">GDK_Var</span></span></code></li></ol></div><div class="spec-doc"><p>Declaration keyword for global storage elements.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-global_decl"><a href="#type-global_decl" class="anchor"></a><code><span><span class="keyword">type</span> global_decl</span><span> = </span><span>{</span></code><ol><li id="type-global_decl.keyword" class="def record field anchored"><a href="#type-global_decl.keyword" class="anchor"></a><code><span>keyword : <a href="#type-global_decl_keyword">global_decl_keyword</a>;</span></code></li><li id="type-global_decl.name" class="def record field anchored"><a href="#type-global_decl.name" class="anchor"></a><code><span>name : <a href="#type-identifier">identifier</a>;</span></code></li><li id="type-global_decl.ty" class="def record field anchored"><a href="#type-global_decl.ty" class="anchor"></a><code><span>ty : <span><a href="#type-ty">ty</a> option</span>;</span></code></li><li id="type-global_decl.initial_value" class="def record field anchored"><a href="#type-global_decl.initial_value" class="anchor"></a><code><span>initial_value : <span><a href="#type-expr">expr</a> option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Global declaration type</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decl_desc"><a href="#type-decl_desc" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p decl_desc</span></span><span> = </span></code><ol><li id="type-decl_desc.D_Func" class="def variant constructor anchored"><a href="#type-decl_desc.D_Func" class="anchor"></a><code><span>| </span><span><span class="constructor">D_Func</span> <span class="keyword">of</span> <span><span class="type-var">'p</span> <a href="#type-func">func</a></span></span></code></li><li id="type-decl_desc.D_GlobalStorage" class="def variant constructor anchored"><a href="#type-decl_desc.D_GlobalStorage" class="anchor"></a><code><span>| </span><span><span class="constructor">D_GlobalStorage</span> <span class="keyword">of</span> <a href="#type-global_decl">global_decl</a></span></code></li><li id="type-decl_desc.D_TypeDecl" class="def variant constructor anchored"><a href="#type-decl_desc.D_TypeDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">D_TypeDecl</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * <a href="#type-ty">ty</a> * <span><span>(<a href="#type-identifier">identifier</a> * <span><a href="#type-field">field</a> list</span>)</span> option</span></span></code></li></ol></div><div class="spec-doc"><p>Declarations, ie. top level statement in a asl file.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decl"><a href="#type-decl" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p decl</span></span><span> = <span><span><span class="type-var">'p</span> <a href="#type-decl_desc">decl_desc</a></span> <a href="#type-annotated">annotated</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p t</span></span><span> = <span><span><span class="type-var">'p</span> <a href="#type-decl">decl</a></span> list</span></span></code></div><div class="spec-doc"><p>Main AST type.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-scope"><a href="#type-scope" class="anchor"></a><code><span><span class="keyword">type</span> scope</span><span> = </span></code><ol><li id="type-scope.Scope_Local" class="def variant constructor anchored"><a href="#type-scope.Scope_Local" class="anchor"></a><code><span>| </span><span><span class="constructor">Scope_Local</span> <span class="keyword">of</span> <a href="#type-identifier">identifier</a> * int</span></code></li><li id="type-scope.Scope_Global" class="def variant constructor anchored"><a href="#type-scope.Scope_Global" class="anchor"></a><code><span>| </span><span><span class="constructor">Scope_Global</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A scope is an unique identifier of the calling site.</p><span class="comment-delim">*)</span></div></li></ol></div></div></div></body></html>