<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Storage (herdtools7.Asllib.Storage)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">herdtools7</a> &#x00BB; <a href="../index.html">Asllib</a> &#x00BB; Storage</nav><header class="odoc-preamble"><h1>Module <code><span>Asllib.Storage</span></code></h1><p>This module produces an map like interface to model memory storage.</p></header><nav class="odoc-toc"><ul><li><a href="#introduction-to-scopes,-mutability-and-blocks">Introduction to scopes, mutability and blocks</a></li><li><a href="#storage-module">Storage module</a></li></ul></nav><div class="odoc-content"><h2 id="introduction-to-scopes,-mutability-and-blocks"><a href="#introduction-to-scopes,-mutability-and-blocks" class="anchor"></a>Introduction to scopes, mutability and blocks</h2><p>The usual implementation and semantics of variables is based on &quot;maps&quot;, i.e. functions from variables to values with a finite domain. We note <code>env</code> such a map.</p><p>As in ASL, to evaluate a program, we distinguish between expressions and statements:</p><ol><li><p>function <code>eval_expr</code> takes as argument an environment and an expression and returns a value. For instance, here is the evaluation of a variable:</p><pre class="language-ocaml"><code>eval_expr env = function
  | E_Var x -&gt; Map.find x env</code></pre></li><li><p>function <code>eval_stmt</code> takes as argument an environment and a statement and returns an environment. For instance here is the execution of a variable declaration:</p><pre class="language-ocaml"><code>eval_stmt env = function
  | S_Decl (x, e) -&gt;
    let v = eval_expr x e in
    Map.add x v env</code></pre></li></ol><p>In a simplified setting, the above scheme suffices to implement mutable variables, mostly because the <code>eval_stmt</code> returns the environment, as illustrated by the rule for assignment, which is the same as the declaration rule.</p><pre class="language-ocaml"><code>eval_stmt env = function
  | S_Assign (x, e) -&gt;
    let v = eval_expr env e in
    Map.add x v env</code></pre><p>Notice that the new binding overwrites the old one, which is no longer accessible.</p><p>The scheme still works in case all variables are global and when expression can perform side effects. Function <code>eval_expr</code> will now return a pair of a value and of an environment, For instance, assume expression <code>E_Incr x</code> that increments the contents of <code>x</code> and return the new value:</p><pre class="language-ocaml"><code>eval_expr env = function
  | E_Incr x -&gt;
    let v = Map.find x env in
    let v = v + 1 in
    (v, Map.add x v env)</code></pre><p>Things get more complicated in the presence of scopes. The root reason is what happens to bindings at scope end. Consider the following ASL code:</p><pre> var s = 0;
 var i = 0;
 while i &lt; n do
   var c = i*i ;
   s = s + c;
   i = i + 1;
 end
 // 'c' is mo longer available, 's' is.</pre><p>According to ASL semantics the variable <code>c</code> exists from its declaration to the end of its enclosing block. One simple implementation for executing a block is as follows:</p><pre class="language-ocaml"><code>let eval_stmt env = function
  | S_Block stmt -&gt;
    ignore (eval_stmt env stmt);
    env</code></pre><p>All extensions performed by the statement <code>stmt</code> from inside the block are discarded.</p><p>However, some variable defined before the block can be assigned inside the block (this is the case of <code>s</code> above), and those modifications have to survive the end of the block... This would lead to the following contradictory implementation:</p><pre class="language-ocaml"><code>let eval_stmt env = function
  | S_Block stmt -&gt; eval_stmt env stmt</code></pre><p>One solution is adding an indirection in environments. En environment is now made of two maps: one for bindings from variables to <i>pointers</i> and another for the &quot;heap&quot; from pointers to values.</p><pre class="language-ocaml"><code>type env = { bds : pointer VarMap.t; heap : value PointerMap.t; }</code></pre><p>The rule for blocks can now discard the bindings and retain the heap:</p><pre class="language-ocaml"><code>let eval_stmt old_env = function
  | S_Block stmt -&gt;
    let new_env =  eval_stmt env stmt in
    { bds = old_env.bds; heap = new_env.heap; }</code></pre><p>One may notice that the heap can be purged of the slots associated to the discarded bindings, some kind of garbage collection. This can be done easily by an additional field in environment 'declared' that records the variables declared in a block - this technique is used in the interpreter.</p><p>The rule for evaluating a variable now performs two successive searches, one for retrieving the pointer and then the value:</p><pre class="language-ocaml"><code>let eval_expr env = function
  | E_Var x -&gt;
    let pointer = VarMap.find x env.bds in
    PointerMap.find pointer env.heap</code></pre><p>The rules for declarations and assignments also change, there are now different:</p><ol><li>The declaration <i>allocates</i> a fresh pointer. That way if a binding for the same variable exists the underlying heap slot is preserved.</li><li>The assignment retrieve the pointer associated to the variable, which must exist.</li></ol><h2 id="storage-module"><a href="#storage-module" class="anchor"></a>Storage module</h2><p>This module implements the storage type presented above, and present a simple interface to this.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'v t</span></span></code></div><div class="spec-doc"><p>The type <code>t</code> stores an association between names and <code>'v</code> values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>An empty storage.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem x t</code> is true iff <code>x</code> is bound in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add x v t</code> is <code>t</code> with <code>x</code> bound to <code>v</code>, over-riding previous bind but not deleting values from memory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assign"><a href="#val-assign" class="anchor"></a><code><span><span class="keyword">val</span> assign : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>assign x v t</code> is <code>t</code> with <code>x</code> bound to <code>v</code>, replacing the previous value bound for <code>x</code>. If <code>x</code> is not bound in <code>t</code>, raise <code>Not_found</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-declare"><a href="#val-declare" class="anchor"></a><code><span><span class="keyword">val</span> declare : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>declare x v t</code> is <code>t</code> with <code>x</code> bound to <code>v</code>, creating a new memory cell for <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>find x t</code> is <code>v</code> if <code>x</code> is bound to <code>v</code> in <code>t</code>, raising <code>Not_found</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt x t</code> is <code>Some v</code> if <code>x</code> is bound to <code>v</code> in <code>t</code>, <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="../AST/index.html#type-identifier">AST.identifier</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>remove x t</code> is <code>t</code> with <code>x</code> not bound to anything. Memory is freed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-patch_mem"><a href="#val-patch_mem" class="anchor"></a><code><span><span class="keyword">val</span> patch_mem : <span>t_env:<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>t_mem:<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../AST/index.html#type-identifier">AST.identifier</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>patch_mem ~t_env ~t_mem to_avoid</code> is the storage formed with the bindings of <code>t_env</code>, the memory of <code>t_mem</code> except for the cells bound to the variables in <code>to_avoid</code>.</p></div></div></div></body></html>